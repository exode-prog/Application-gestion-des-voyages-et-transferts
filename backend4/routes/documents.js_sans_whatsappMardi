const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
//const Document = require('../models/Document');
const { Document, Formulaire } = require('../models/Document');
const { auth } = require('../middleware/auth');
const { generateUniqueReference } = require('../utils/referenceGenerator');

//gerer notifications
const { sendNewSubmissionNotification, sendRejectionNotification } = require('../services/emailService');
// ==========================================
// ‚úÖ CONFIGURATION MULTER - STOCKAGE EN M√âMOIRE
// ==========================================

const storage = multer.memoryStorage(); // ‚úÖ Stockage en RAM, pas sur disque

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 12 * 1024 * 1024 // 12MB max par fichier
  },
  fileFilter: (req, file, cb) => {
    // V√©rification de la taille AVANT upload
    if (file.size > 12 * 1024 * 1024) {
      return cb(new Error('Fichier trop volumineux (max 12MB)'));
    }
    cb(null, true);
  }
});

// ==========================================
// ‚úÖ FONCTION : Convertir Buffer en Base64
// ==========================================
const convertirEnBase64 = (buffer) => {
  return buffer.toString('base64');
};

// ==========================================
// ‚úÖ FONCTION : Convertir Base64 en Buffer
// ==========================================
const convertirEnBuffer = (base64String) => {
  return Buffer.from(base64String, 'base64');
};

// ==========================================
// ‚úÖ ROUTE PUBLIQUE - SOUMISSION VOYAGE
// ==========================================

router.post('/submit', upload.any(), async (req, res) => {
  console.log('=== SUBMIT VOYAGE avec stockage MongoDB ===');
  console.log('üì¶ Body:', req.body);
  console.log('üìé Files:', req.files?.length || 0);

  try {
    const { 
      nom, prenom, email, telephone, profession, sexe,
      pays, raison, autreRaison,
      dateDebut, dateFin 
    } = req.body;
    
    // Validation des champs requis
    if (!nom || !prenom || !email || !telephone || !profession || !sexe || 
        !pays || !raison || !dateDebut || !dateFin) {
      return res.status(400).json({
        success: false,
        message: 'Tous les champs sont requis'
      });
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Au moins un fichier est requis'
      });
    }

    // ‚úÖ V√©rifier la taille de chaque fichier
    for (const file of req.files) {
      try {
        Document.verifierTailleFichier(file.size);
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: `${file.originalname}: ${error.message}`
        });
      }
    }

    // ‚úÖ G√©n√©ration de r√©f√©rence unique
    const reference = await generateUniqueReference(Document, 'DOC');
    const today = new Date().toISOString().split('T')[0];

    // ‚úÖ Convertir les fichiers en Base64
    console.log('üìé Conversion des fichiers en Base64...');
    const fichiers = req.files.map((file, index) => {
      console.log(`  Fichier ${index + 1}:`, file.originalname, file.size, 'bytes');
      
      const base64Content = convertirEnBase64(file.buffer);
      console.log(`  ‚úì Base64 g√©n√©r√©:`, base64Content.substring(0, 50) + '...');
      
      const fichierData = {
        nom: `${path.parse(file.originalname).name}_${Date.now()}${path.extname(file.originalname)}`,
        nomOriginal: file.originalname,
        taille: file.size,
        extension: path.extname(file.originalname),
        mimeType: file.mimetype,
        contenuBase64: base64Content,
        dateUpload: new Date()
      };
      
      console.log(`  ‚úì Fichier structur√©:`, {
        nom: fichierData.nom,
        nomOriginal: fichierData.nomOriginal,
        taille: fichierData.taille,
        extension: fichierData.extension,
        mimeType: fichierData.mimeType,
        hasBase64: !!fichierData.contenuBase64
      });
      
      return fichierData;
    });

    console.log(`‚úÖ ${fichiers.length} fichiers convertis en Base64`);
    console.log('üìã Fichiers pr√©par√©s:', fichiers.map(f => ({
      nom: f.nomOriginal,
      taille: f.taille,
      mimeType: f.mimeType,
      hasBase64: !!f.contenuBase64
    })));

  

    // ‚úÖ V√©rifier si le client existe d√©j√†
    const clientExistant = await Document.findOne({
      nom: nom.trim(),
      prenom: prenom.trim(),
      email: email.toLowerCase().trim(),
      typeDocument: 'voyage'
    });

    // ‚úÖ Cr√©er le sous-dossier
    const sousDossier = {
      nom: today,
      date: new Date(),
      motif: raison === 'autres' ? autreRaison : raison,
      fichiers
    };

    let documentSauve;
    let isNouveauClient = false;

    if (clientExistant) {
      // ‚úÖ Client existe : ajouter un sous-dossier
      console.log(`‚úÖ Client existant trouv√©: ${clientExistant.reference}, ajout d'un sous-dossier`);
      
      // V√©rifier la taille totale AVANT d'ajouter
      try {
        const tousFichiers = [...clientExistant.sousDossiers.flatMap(sd => sd.fichiers), ...fichiers];
        Document.verifierTailleTotale(tousFichiers);
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      
      clientExistant.sousDossiers.push(sousDossier);
      clientExistant.dateModification = new Date();
      documentSauve = await clientExistant.save();
      
      console.log(`‚úÖ Nouveau sous-dossier ajout√© au client existant: ${today}`);
    } else {
      // ‚úÖ Nouveau client : cr√©er un nouveau document
      isNouveauClient = true;
      
      // V√©rifier la taille totale
      try {
        Document.verifierTailleTotale(fichiers);
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }

      const nouveauDocument = new Document({
        reference,
        nom: nom.trim(),
        prenom: prenom.trim(),
        email: email.toLowerCase().trim(),
        telephone: telephone.trim(),
        profession: profession.trim(),
        sexe,
        typeDocument: 'voyage',
        pays,
        raison,
        autreRaison: raison === 'autres' ? autreRaison : undefined,
        dateDebut: new Date(dateDebut),
        dateFin: new Date(dateFin),
        sousDossiers: [sousDossier],
        statut: 'en_attente'
      });
      
      documentSauve = await nouveauDocument.save();
      console.log('‚úÖ Nouveau document VOYAGE cr√©√© dans MongoDB:', reference);
    }
    
    console.log(`üìä Taille totale: ${(documentSauve.getTailleTotale() / 1024 / 1024).toFixed(2)}MB`);
    await sendNewSubmissionNotification(documentSauve, 'voyage');

    res.status(201).json({
      success: true,
      message: isNouveauClient ? 'Documents de voyage soumis avec succ√®s' : 'Nouveau sous-dossier ajout√© avec succ√®s',
      reference: documentSauve.reference,
      document: {
        _id: documentSauve._id,
        reference: documentSauve.reference,
        nom: documentSauve.nom,
        prenom: documentSauve.prenom,
        email: documentSauve.email,
        statut: documentSauve.statut,
        typeDocument: 'voyage',
        nombreFichiers: documentSauve.getNombreFichiers(),
        tailleTotale: documentSauve.getTailleTotale(),
        nombreSousDossiers: documentSauve.sousDossiers.length
      }
    });
    console.log(`üìä Taille totale: ${(nouveauDocument.getTailleTotale() / 1024 / 1024).toFixed(2)}MB`);
    await sendNewSubmissionNotification(nouveauDocument, 'voyage');

    res.status(201).json({
      success: true,
      message: 'Documents de voyage soumis avec succ√®s',
      reference,
      document: {
        _id: nouveauDocument._id,
        reference: nouveauDocument.reference,
        nom: nouveauDocument.nom,
        prenom: nouveauDocument.prenom,
        email: nouveauDocument.email,
        statut: nouveauDocument.statut,
        typeDocument: 'voyage',
        nombreFichiers: nouveauDocument.getNombreFichiers(),
        tailleTotale: nouveauDocument.getTailleTotale()
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur soumission voyage:', error);
    
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la soumission: ' + error.message
    });
  }
});

// ==========================================
// ‚úÖ ROUTE PUBLIQUE - SOUMISSION TRANSFERT
// ==========================================



router.post('/submit-transfert', upload.any(), async (req, res) => {
  console.log('=== SUBMIT TRANSFERT avec stockage MongoDB ===');
  console.log('üì¶ Body:', req.body);
  console.log('üìé Files:', req.files?.length || 0);

  try {
    const { 
      nom, prenom, email, telephone, profession, sexe,
      typeTransfert,
      dateDebut, dateFin 
    } = req.body;
    
    // ‚úÖ MODIFICATION : Supprimer dateDebut et dateFin des champs requis
    if (!nom || !prenom || !email || !telephone || !profession || !sexe || 
        !typeTransfert) {
      return res.status(400).json({
        success: false,
        message: 'Tous les champs sont requis'
      });
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Au moins un fichier est requis'
      });
    }

    // V√©rifier taille des fichiers
    for (const file of req.files) {
      try {
        Document.verifierTailleFichier(file.size);
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: `${file.originalname}: ${error.message}`
        });
      }
    }

    const reference = await generateUniqueReference(Document, 'TRF');
    const today = new Date().toISOString().split('T')[0];

    // ‚úÖ Convertir les fichiers en Base64
    const fichiers = req.files.map(file => {
      const base64Content = convertirEnBase64(file.buffer);
      
      return {
        nom: `${path.parse(file.originalname).name}_${Date.now()}${path.extname(file.originalname)}`,
        nomOriginal: file.originalname,
        taille: file.size,
        extension: path.extname(file.originalname),
        mimeType: file.mimetype,
        contenuBase64: base64Content,
        dateUpload: new Date()
      };
    });

    const sousDossier = {
      nom: today,
      date: new Date(),
      motif: typeTransfert,
      fichiers
    };

    const nouveauDocument = new Document({
      reference,
      nom: nom.trim(),
      prenom: prenom.trim(),
      email: email.toLowerCase().trim(),
      telephone: telephone.trim(),
      profession: profession.trim(),
      sexe,
      typeDocument: 'transfert',
      typeTransfert,
      // ‚úÖ MODIFICATION : Rendre les dates optionnelles
      dateDebut: dateDebut ? new Date(dateDebut) : undefined,
      dateFin: dateFin ? new Date(dateFin) : undefined,
      sousDossiers: [sousDossier],
      statut: 'en_attente'
    });

    try {
      Document.verifierTailleTotale(fichiers);
    } catch (error) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }

    await nouveauDocument.save();
    
    console.log('‚úÖ Document TRANSFERT cr√©√© dans MongoDB:', reference);
    await sendNewSubmissionNotification(nouveauDocument, 'transfert');

    res.status(201).json({
      success: true,
      message: 'Dossier de transfert soumis avec succ√®s',
      reference,
      document: {
        _id: nouveauDocument._id,
        reference: nouveauDocument.reference,
        nom: nouveauDocument.nom,
        prenom: nouveauDocument.prenom,
        email: nouveauDocument.email,
        statut: nouveauDocument.statut,
        typeDocument: 'transfert',
        nombreFichiers: nouveauDocument.getNombreFichiers(),
        tailleTotale: nouveauDocument.getTailleTotale()
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur soumission transfert:', error);
    
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la soumission: ' + error.message
    });
  }
});



// ==========================================
// ROUTES ADMIN - CONSULTATION
// ==========================================

router.get('/admin/dossiers', auth, async (req, res) => {
  try {
    const { typeDocument, statut } = req.query;
    
    const filtres = {};
    if (typeDocument) filtres.typeDocument = typeDocument;
    if (statut) filtres.statut = statut;

    // ‚úÖ Exclure le contenu Base64 pour la liste (performance)
    const documents = await Document.find(filtres)
      .select('-sousDossiers.fichiers.contenuBase64') // Ne pas charger les fichiers
      .sort({ dateCreation: -1 })
      .lean();

    const dossiersFormates = documents.map(doc => ({
      _id: doc._id,
      reference: doc.reference,
      nom: doc.nom,
      prenom: doc.prenom,
      email: doc.email,
      telephone: doc.telephone,
      profession: doc.profession,
      sexe: doc.sexe,
      typeDocument: doc.typeDocument,
      pays: doc.pays,
      raison: doc.raison,
      autreRaison: doc.autreRaison,
      typeTransfert: doc.typeTransfert,
      dateDebut: doc.dateDebut,
      dateFin: doc.dateFin,
      statut: doc.statut,
      motifRejet: doc.motifRejet,
      dateCreation: doc.dateCreation,
      sousDossiers: doc.sousDossiers.map(sd => ({
        _id: sd._id,
        nom: sd.nom,
        date: sd.date,
        motif: sd.motif,
        fichiers: sd.fichiers.map(f => ({
          _id: f._id,
          nom: f.nom,
          nomOriginal: f.nomOriginal,
          taille: f.taille,
          extension: f.extension,
          mimeType: f.mimeType,
          dateUpload: f.dateUpload
          // ‚ùå PAS contenuBase64 pour optimiser
        }))
      }))
    }));

    res.json({
      success: true,
      dossiers: dossiersFormates
    });

  } catch (error) {
    console.error('Erreur r√©cup√©ration dossiers:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur: ' + error.message
    });
  }
});

// ==========================================
// ROUTES ADMIN - MODIFICATION
// ==========================================



router.patch('/admin/statut/:reference', auth, async (req, res) => {
  try {
    const { reference } = req.params;
    const { statut, motifRejet } = req.body;

    const validStatuts = ['en_attente', 'partiellement_apur√©', 'apur√©', 'archiv√©', 'rejet√©'];
    if (!validStatuts.includes(statut)) {
      return res.status(400).json({
        success: false,
        message: `Statut invalide`
      });
    }

    const updateData = {
      statut: statut,
      dateModification: new Date()
    };

    if (motifRejet) {
      updateData.motifRejet = motifRejet;
    }

    const document = await Document.findOneAndUpdate(
      { reference },
      updateData,
      { new: true }
    ).select('-sousDossiers.fichiers.contenuBase64');

    if (!document) {
      return res.status(404).json({
        success: false,
        message: 'Document non trouv√©'
      });
    }

    // ‚úÖ ENVOI EMAIL SI REJET
    if (statut === 'rejet√©' && motifRejet) {
      try {
        console.log('üìß D√©clenchement envoi notifications rejet...');
        const emailResult = await sendRejectionNotification(
          document, 
          motifRejet, 
          document.typeDocument
        );
        
        console.log('üìß R√©sultat envoi notifications:', emailResult);
        
        if (!emailResult.success) {
          console.warn('‚ö†Ô∏è Probl√®me lors de l\'envoi des emails de rejet');
        }
      } catch (emailError) {
        console.error('‚ùå Erreur envoi emails rejet:', emailError);
        // Ne pas bloquer la r√©ponse m√™me si l'email √©choue
      }
    }

    res.json({
      success: true,
      message: 'Statut mis √† jour avec succ√®s',
      document: {
        reference: document.reference,
        statut: document.statut,
        motifRejet: document.motifRejet || null
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur changement statut:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur: ' + error.message
    });
  }
});


// ==========================================
// ROUTES ADMIN - SUPPRESSION
// ==========================================

router.delete('/admin/dossier/:reference', auth, async (req, res) => {
  try {
    const { reference } = req.params;
    const document = await Document.findOne({ reference });
    
    if (!document) {
      return res.status(404).json({
        success: false,
        message: 'Document non trouv√©'
      });
    }

    // ‚úÖ Suppression simple : tout est dans MongoDB
    await Document.findOneAndDelete({ reference });
    
    console.log(`‚úÖ Document supprim√© de MongoDB: ${reference}`);

    res.json({
      success: true,
      message: 'Document supprim√© avec succ√®s'
    });

  } catch (error) {
    console.error('Erreur suppression:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur: ' + error.message
    });
  }
});

router.delete('/admin/sousdossier/:reference/:sousDossierId', auth, async (req, res) => {
  try {
    const { reference, sousDossierId } = req.params;
    
    const document = await Document.findOne({ reference });
    
    if (!document) {
      return res.status(404).json({
        success: false,
        message: 'Document non trouv√©'
      });
    }

    const sousDossier = document.sousDossiers.id(sousDossierId);
    
    if (!sousDossier) {
      return res.status(404).json({
        success: false,
        message: 'Sous-dossier non trouv√©'
      });
    }

    // ‚úÖ Suppression simple : retirer du tableau
    document.sousDossiers.pull(sousDossierId);
    await document.save();

    console.log(`‚úÖ Sous-dossier supprim√©: ${sousDossierId}`);

    res.json({
      success: true,
      message: 'Sous-dossier supprim√© avec succ√®s'
    });

  } catch (error) {
    console.error('Erreur suppression sous-dossier:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur: ' + error.message
    });
  }
});

router.delete('/admin/file/:reference/:sousDossierId/:fileId', auth, async (req, res) => {
  try {
    const { reference, sousDossierId, fileId } = req.params;
    
    const document = await Document.findOne({ reference });
    
    if (!document) {
      return res.status(404).json({
        success: false,
        message: 'Document non trouv√©'
      });
    }

    const sousDossier = document.sousDossiers.id(sousDossierId);
    const fichier = sousDossier?.fichiers.id(fileId);
    
    if (!fichier) {
      return res.status(404).json({
        success: false,
        message: 'Fichier non trouv√©'
      });
    }

    // ‚úÖ Suppression simple : retirer du tableau
    sousDossier.fichiers.pull(fileId);
    await document.save();

    console.log(`‚úÖ Fichier supprim√©: ${fichier.nomOriginal}`);

    res.json({
      success: true,
      message: 'Fichier supprim√© avec succ√®s'
    });

  } catch (error) {
    console.error('Erreur suppression fichier:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur: ' + error.message
    });
  }
});





const uploadFormulaire = multer({
  storage: multer.memoryStorage(), // Stockage en m√©moire pour conversion Base64
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB max
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Seuls les fichiers PDF sont autoris√©s'), false);
    }
  }
});



// Route pour uploader le formulaire client dans MongoDB
router.post('/admin/formulaire-client', auth, uploadFormulaire.single('formulaire'), async (req, res) => {
  try {
    console.log('=== D√âBUT UPLOAD FORMULAIRE CLIENT ===');
    console.log('üë§ User:', req.user);
    console.log('üìÅ File:', req.file ? {
      originalname: req.file.originalname,
      size: req.file.size,
      mimetype: req.file.mimetype
    } : 'Aucun fichier');

    // V√©rifier que l'utilisateur est superviseur
    if (req.user.role !== 'superviseur') {
      console.log('‚ùå Acc√®s refus√© - R√¥le:', req.user.role);
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√©. Seuls les superviseurs peuvent uploader des formulaires.'
      });
    }

    if (!req.file) {
      console.log('‚ùå Aucun fichier fourni');
      return res.status(400).json({
        success: false,
        message: 'Aucun fichier fourni'
      });
    }

    // V√©rifier la taille du fichier
    if (req.file.size > 10 * 1024 * 1024) {
      console.log('‚ùå Fichier trop volumineux:', req.file.size);
      return res.status(400).json({
        success: false,
        message: 'Fichier trop volumineux (max 10MB)'
      });
    }

    // ‚úÖ SOLUTION : Utiliser la m√©thode statique correctement
    console.log('‚úÖ Appel de la m√©thode statique updateFormulaireClient...');
    
    const formulaire = await Formulaire.schema.statics.updateFormulaireClient.call(
      Formulaire,
      req.file, 
      req.user.username
    );

    console.log(`‚úÖ Formulaire client sauvegard√© dans MongoDB: ${formulaire.nomOriginal}`);
    
    res.json({
      success: true,
      message: 'Formulaire client mis √† jour avec succ√®s',
      file: {
        nomOriginal: formulaire.nomOriginal,
        taille: formulaire.taille,
        dateUpload: formulaire.dateUpload,
        uploader: formulaire.uploader
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur upload formulaire client:', error);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour du formulaire: ' + error.message
    });
  }
});

// Route publique pour t√©l√©charger le formulaire depuis MongoDB
router.get('/formulaire-limite.pdf', async (req, res) => {
  try {
    const { Formulaire } = require('../models/Document');
    
    // R√©cup√©rer le formulaire depuis MongoDB
    const formulaire = await Formulaire.findOne({ nom: 'formulaire-limite' });
    
    if (!formulaire) {
      return res.status(404).json({
        success: false,
        message: 'Formulaire non disponible'
      });
    }

    // Convertir Base64 en Buffer
    const buffer = Buffer.from(formulaire.contenuBase64, 'base64');

    // Envoyer le fichier
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename="formulaire-limite.pdf"');
    res.setHeader('Content-Length', buffer.length);
    
    res.send(buffer);

    console.log('‚úÖ Formulaire client t√©l√©charg√© depuis MongoDB');

  } catch (error) {
    console.error('‚ùå Erreur t√©l√©chargement formulaire:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors du t√©l√©chargement du formulaire'
    });
  }
});

// Route pour obtenir les infos du formulaire (optionnel)
router.get('/admin/formulaire-info', auth, async (req, res) => {
  try {
    const { Formulaire } = require('../models/Document');
    
    const formulaire = await Formulaire.findOne({ nom: 'formulaire-limite' });
    
    if (!formulaire) {
      return res.status(404).json({
        success: false,
        message: 'Aucun formulaire disponible'
      });
    }

    res.json({
      success: true,
      formulaire: {
        nomOriginal: formulaire.nomOriginal,
        taille: formulaire.taille,
        dateUpload: formulaire.dateUpload,
        uploader: formulaire.uploader
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration info formulaire:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des informations'
    });
  }
});



// ==========================================
// ‚úÖ ROUTES ADMIN - T√âL√âCHARGEMENT (Base64 ‚Üí Buffer)
// ==========================================

router.get('/admin/download/:reference/:sousDossierId/:fileId', auth, async (req, res) => {
  try {
    const { reference, sousDossierId, fileId } = req.params;

    const document = await Document.findOne({ reference });
    
    if (!document) {
      return res.status(404).json({
        success: false,
        message: 'Document non trouv√©'
      });
    }

    const sousDossier = document.sousDossiers.id(sousDossierId);
    const fichier = sousDossier?.fichiers.id(fileId);
    
    if (!fichier) {
      return res.status(404).json({
        success: false,
        message: 'Fichier non trouv√©'
      });
    }

    // ‚úÖ Convertir Base64 en Buffer
    const buffer = convertirEnBuffer(fichier.contenuBase64);

    // ‚úÖ Envoyer le fichier
    res.set({
      'Content-Type': fichier.mimeType || 'application/octet-stream',
      'Content-Disposition': `attachment; filename="${encodeURIComponent(fichier.nomOriginal)}"`,
      'Content-Length': buffer.length
    });

    res.send(buffer);

    console.log(`‚úÖ Fichier t√©l√©charg√©: ${fichier.nomOriginal} (${(fichier.taille / 1024).toFixed(2)}KB)`);

  } catch (error) {
    console.error('Erreur t√©l√©chargement:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur: ' + error.message
    });
  }
});

module.exports = router;
